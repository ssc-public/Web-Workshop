<<<<<<< HEAD
<p align="center">
    <img src="https://github.com/AryanAhadinia/web_workshop/blob/redis_article/Redis/public/redis_logo.svg" alt="Redis Logo">
</p>

<p align="center">
    تحقیق پایانی برنامه سازی وب، دانشگاه صنعتی شریف
    <br/>
    ارائه دهنده درس: جناب آقای امید جعفری نژاد
    <br/>
    نویسندگان: آرین احدی نیا، محمد جعفری، پوریا ممتاز اصفهانی
</p>

<div dir="rtl">

## ردیس چیست؟

ردیس یک انبار در حافظه داده ساختار (in-memory data structure store) است که میتواند به عنوان پایگاه داده یا حافظه نهان (cache) یا کارگزار پیام (message broker) استفاده شود.
ردیس داده ساختار هایی را از قبیل رشته (strings)، هش (hashes)، لیست (lists)، مجموعه (sets)، مجموعه مرتب (sorted sets)، بیتمپ (bitmaps)، جریان ها (streams) و ... ارائه میدهد.
ردیس، مجموعه ای از امکانات دخلی از قبیل تکرر (replication)، اسکیریپ نویسی لوآ (Lua scripting)، تخلیه LRU و ... را ارائه میدهد.

ردیس در خانواده پایگاه داده های کلید-مقدار (key-value) قرار میگیرد.
از آنجایی که ردیس رویه کلید-مقداری دارد. اغلب به عنوان یک داده ساختار معرفی میشود.

## متن باز

خبر خوب اینکه ردیس یک پروژه متن باز است و شما می توانید به متن منبع این پروژه در GitHub دسترسی پیدا کنید.
[github.com/redis](https://github.com/redis)

## نصب ردیس

روش های مختلفی برای نصب ردیس وجود دارد. در این مقاله، ما به نصب ردیس در داکر، در لینوکس و در ویندوز اشاره می کنیم.
اگر شما یک توسعه دهنده هستید و میخواهید از ردیس برای اجرا و تست پروژه خود استفاده کنید، قویا استفاده از داکر را به شما توصیه می کنیم.

### نصب در لینوکس

برای نصب در لینوکس روش های متعددی وجود دارد. ما در اینجا یک روش نصب و ایمن‌سازی آن را برای سرور های ubuntu بیان می کنیم. هرچند که از این روش برای نصب در ubuntu lts نیز میتوانید استفاده کنید.

#### پیشنیاز ها

شما برای طی مراحل این نصب، به یک ubuntu server و دسترسی sudo نیاز دارید.

#### مراحل

1. با استفاده از دستور زیر، ردیس و dependencies هایش را نصب کنید.

<div dir="ltr">

```
$ sudo apt update
$ sudo apt install redis-server
```

</div>

2. با استفاده از دستور زیر فایل config ردیس را باز کنید.

<div dir="ltr">

```
$ sudo nano /etc/redis/redis.conf
```

</div>

یک فایل مشابه تصویر زیر باز خواهد شد. مقابل `supervised` عبارت `no` نوشته شده است. آن را به `systemd` تغییر دهید.
این تغییر اجازه میدهد که سیستم به بتواند به عنوان یک سرویس با ردیس برخورد کند.

<img src="https://github.com/AryanAhadinia/web_workshop/blob/redis_article/Redis/public/ubuntu/ubuntu_1.png" alt="ubuntu_1">

3. برای اعمال تغییرات اعمال شده در مرحله قبل دستور زیر را اجرا کنید.

<div dir="ltr">

```
$ sudo systemctl restart redis.service
```

</div>

4. حال میتوانید با استفاده از دستور زیر به redis-cli وصل شوید.

<div dir="ltr">

```
$ redis-cli
```

</div>

5. برای تست می توانید از دستور `ping` استفاده کنید. پاسخ مورد انتظار در صورت اجرای مناسب، `PONG` خواهد بود.

<div dir="ltr">

```
> ping
PONG
```

</div>

6. با استفاده از دستور `exit` میتوانید خارج شوید.

<div dir="ltr">

```
> exit
```

</div>

7. در صورتی که تمایل به تنظیم رمزعبور برای ردیس دارید، این بخش را دنبال کنید.
   تنظیم رمزعبور یکی از دو قابلیت امنیتی ردیس است که کاربران را ملزم می کند برای دسترسی به آن، با استفاده از رمز عبور احراز هویت کنند. رمز عبور از طریق فایل `config` ردیس تنظیم میشود. برای تنظیم رمز عبور، فایل `config` را با استفاده از دستور زیر باز کنید.

<div dir="ltr">

```
$ sudo nano /etc/redis/redis.conf
```

</div>

اسکرول کنید تا به بخش `SECURITY` برسید. در آنجا یک خط کامنت شده به شکل زیر وجود دارد.

<div dir="ltr">

```
# requirepass foobared
```

</div>

برای تنظیم رمزعبور، با حذف # آن را از حالت کامنت دربیاورید و عبارت foobared را با یک رمز عبور امن جایگزین کنید.

<img src="https://github.com/AryanAhadinia/web_workshop/blob/redis_article/Redis/public/ubuntu/ubuntu_2.png" alt="ubuntu_2">

##### توجه

در همین قسمت، مطابق تصویر بالا نوشته شده است که به علت سرعت بالای ردیس، کاربران خارجی با بسامد 150k تلاش در ثانیه، میتوانند پسورد ها را تولید و امتحان کنند.
این موضوع خطر حمله جستوجوی کور را بالا می برد.
لذا توصیه میشود که از یک پسورد طولانی که ترکیب حروف و اعداد و نماد است استفاده کنید.
برای اینکار می توانید از نرم‌افزار های تولید رشته های تصادفی مانند `open ssl` استفاده کنید.

پس از تنظیم رمزعبور، تغییرات را ذخیره و فایل را ببندید و از دستور زیر برای اعمال تغییرات استفاده کنید.

<div dir="ltr">

```
$ sudo systemctl restart redis.service
```

</div>

اکنون ردیس تنها پس از احراز هویت با رمزعبور، کار خواهد کرد. مثال:

<div dir="ltr">

```
$ redis-cli
> set key 1
(error) NOAUTH Authentication required.
> auth 1234
OK
> set key 1
OK
quit
```

</div>

8. این یک قابلیت امنیتی برای تغییر نام دستورهای خطرناک است. در صورتی که تمایلی به انجام آن ندارید، می توانید این بخش را دنبال نکنید.
   یک قابلیت امنیتی دیگر که ردیس فراهم می آورد. تغییر نام یا غیر فعال کردن دستوراتی است که اجرای آنها میتواند خطرناک باشد.
   اجرای این دستورها میتواند اتفاقی یا باشد یا توسط بدخواهان خارجی اتفاق بیفتد.

به عنوان مثال دستور زیر میتواند پسورد تنظیم شده را آشکار کند.

<div dir="ltr">

```
> config get requirepass
1) "requirepass"
2) "1234"
```

</div>

دستورهای لیست زیر از جمله دستورهای خطرناک هستند. هر چند که این لیست، جامع نیست.

<div dir="ltr">

```
FLUSHDB
FLUSHALL
KEYS
PEXPIRE
DEL
CONFIG
SHUTDOWN
BGREWRITEAOF
BGSAVE
SAVE
SPOP
SREM
RENAME
DEBUG
```

</div>

لیست کامل دستورهای ردیس را میتوانید از لینک روبرو دریافت کنید.
[http://redis.io/commands](http://redis.io/commands)

فراخور نیاز هر پروژه، میتوانید نام دستورهای خطرناک را به یک نام دلخواه تغییر دهید یا به صورت کلی اجرای آن دستور را غیر فعال کنید.
مشابه تنظیم رمزعبور، این کار از بخش `SECURITY` فایل تنظیم انجام میشود. کافیست که فایل مورد نظر را با استفاده از دستور زیر باز کنید.

<div dir="ltr">

```
$ sudo nano /etc/redis/redis.conf
```

</div>

سپس در بخش امنیت، مشابه تصویر زیر به بخش تغییر نام دستورات بروید. آنجا میتوانید دستورات تغییر نام را مشابه تصویر بنویسید.
توجه کنید که برای غیر فعال کردن، کافی است که نام آن را به یک رشته خالی تغییر دهید.

<img src="https://github.com/AryanAhadinia/web_workshop/blob/redis_article/Redis/public/ubuntu/ubuntu_3.png" alt="ubuntu_3">

### نصب در داکر

استفاده از این روش، به دلیل سادگی و سهولت قویا توصیه میشود. با طی مراحل زیر، میتوانید ردیس را در داکر خود نصب کنید.

#### پیشنیاز ها

1. command line
2. یک عدد داکر صحیح و سالم و در وضعیت running
3. کاربر با دسترسی admin در سیستم عامل (sudo و root در لینوکس)

#### مراحل

1. با استفاده از دستور زیر، یک کانینر ردیس با نام دلخواه باز کنید. در صورت لزوم میتوانید نسخه نصب را نیز مشخص کنید. در دستور زیر چون نسخه نصب را مشخص نکرده ایم، سیستم به صورت خودکار آخرین نسخه (latest) را نصب خواهد کرد.

<div dir="ltr">

```
docker run --name my-first-redis -d redis
```

</div>

در تصویر پایین، تصویر ترمینال پس از اجرای موفقیت آمیز این دستور قرار دارد.

2. دستور زیر را در ترمینال اجرا کنید تا مطابق تصویر، از صحت نصب و اجرای ردیس اطلاع پیدا کنید.

<div dir="ltr">

```
docker ps
```

</div>

<img src="https://github.com/AryanAhadinia/web_workshop/blob/redis_article/Redis/public/docker/docker_1.png" alt="docker_1">

تمام شد! ردیس شما آماده است. میتوانید از طریق دستورات زیر به redis-cli در کامندلاین دسترسی پیدا کنید.

3. از دستور زیر برای باز کردن redis-cli استفاده کنید.

<div dir="ltr">

```
docker exec -it my-first-redis sh
redis-cli
```

</div>

4. میتوانید از دستور `ping` برای بررسی وجود اتصال مناسب استفاده کنید. در صورتی که اتصال برقرار باشد پاسخ `PONG` دریافت خواهد شد.

<img src="https://github.com/AryanAhadinia/web_workshop/blob/redis_article/Redis/public/docker/docker_2.png" alt="docker_2">

5. ممکن است که به هر دلیلی بخواهید ردیس با فایل کانفیگ دلخواه شما اجرا شود. این دلایل میتوانند دلایل امنیتی باشند که در مرحله 7 و 8 نصب در لینوکس توضیح دادیم.
   برای اجرای ردیس با فایل کانفیگ دلخواه، کافی است ردیس را با دستور زیر اجرا کنید.

<div dir="ltr">

```
sudo docker run --name my-first-redis -v /myfirstredis/redis.conf:/path/to/redis/redis.conf -d redis
```

</div>

## نصب در ویندوز

نصب ردیس در ویندوز سرراست است و صرفا با دانلود فایل اجرایی نصب، صورت می گیرد. استفاده از آن نیز بسیار آسان استو کافی است که فایل redis-server.exe را اجرا کنید. در نهایت میتوانید با استفاده از دستور `ping`، صحت اتصال را بررسی کنید.

<div dir="ltr">

```
> ping
PONG
```

</div>

## پله پله تا دستور های ردیس

برای شروع، میتوانیم از دستور زیر، برای ذخییره مقدار "fido" در کلید "server:name" استفاده کنیم.

<div dir="ltr">

```
SET server:name "fido"
```

</div>

می توانیم برای دریافت مقدار ذخیره شده در یک کلید مانند "server:name" از دستور زیر استفاده کنیم.

<div dir="ltr">

```
GET server:name
    => fido
```

</div>

اگر برای دریافت مقدار یک کلید مقداردهی نشده درخواست کنیم، nil دریافت خواهیم کرد.
=======


<p align="center" style="text-align:center" >
  <img src="https://cdn.iconscout.com/icon/free/png-512/redis-3-1175053.png" alt="Redis image"/>
</p>


 <div align="center">
  تهیه کنندگان : زینب احیایی - نرگس جاوید - آتنا ساقی 
</div>
 
<div dir="rtl">

##  مقدمه 

Redis که کوتاه‌ شده‌ی Remote Dictionary Server می باشد؛ یک نوع پایگاه داده‌ی ‌ in-memory (به این معنای که از memory برای ذخیره سازی استفاده می‌کند) و توزیع شده‌است که داده‌ها به صورت دوتایی key-value ذخیره می‌شوند. 
Redis از انواع مختلف ساختارهای داده  ، مانند رشته ها ، لیست ها ،maps ، مجموعه ها ، مجموعه های مرتب شده ، HyperLogLogs ، bitmaps ،  streams spatial indexes پشتیبانی می کند.
این پروژه توسط تیم اصلی پروژه توسعه و نگهداری و از سال 2015 توسط آزمایشگاه های Redis حمایت مالی می شود. 

Redis که کوتاه‌ شده‌ی Remote Dictionary Server می باشد؛ یک نوع پایگاه داده‌ی ‌ in-memory (به این معنای که از memory برای ذخیره سازی استفاده می‌کند) و توزیع شده‌است که داده‌ها به صورت دوتایی key-value ذخیره می‌شوند. 
Redis از انواع مختلف ساختارهای داده  ، مانند رشته ها ، لیست ها ،maps ، مجموعه ها ، مجموعه های مرتب شده ، HyperLogLogs ، bitmaps ،  streams spatial indexes پشتیبانی می کند.
این پروژه توسط تیم اصلی پروژه توسعه و نگهداری و از سال 2015 توسط آزمایشگاه های Redis حمایت مالی می شود. 

## تاریخچه 
پروژه Redis از آنجا شروع شد که Salvatore Sanfilippo ، ملقب به antirez ، توسعه دهنده اصلی Redis ، در تلاش بود مقیاس پذیری استارتاپ ایتالیایی خود را بهبود بخشد ، و یک تحلیلگر real-time  سیستم وب ایجاد کند. Sanfilippo پس از مواجهه با مشکلات قابل توجه در مقیاس بندی برخی از انواع بارهای کاری با استفاده از سیستم های پایگاه داده سنتی ، شروع به ساخت نمونه اولیه اولین نسخه مفهوم Redis در Tcl کرد. مدتی بعد Sanfilippo آن نمونه اولیه را به زبان C ترجمه كرد و لیست را پیاده سازی كرد. بعد از چند هفته استفاده موفقیت آمیز از پروژه ، سان فیلیپو آن را open-source کرد . این پروژه مورد توجه قرار گرفت ، بیشتر در بین جامعه Ruby ، با GitHub و اینستاگرام از جمله اولین شرکت هایی بودند که آن را به کار گرفتند. 

Sanfilippo در مارس 2010 توسط VMware استخدام شد.

در ماه مه 2013 ، Redis توسط نرم افزار Pivotal (یک بخش تبلیغاتی VMware) حمایت مالی شد.

در ژوئن 2015 ، توسعه توسط آزمایشگاه های Redis حمایت مالی شد.

در اکتبر 2018 Redis 5.0 با معرفی Redis Stream - ساختار داده ای جدیدی که امکان ذخیره چندین زمینه و مقادیر رشته را با توالی خودکار و مبتنی بر زمان در یک کلید فراهم می کند ، منتشر شد. 


## محبوبیت 


با توجه به رتبه بندی DB-engines اغلب Redis به عنوان محبوب‌ترین پایگاه داده‌ی key-value قرار دارد. هم چنین در بین پایگاه‌ داده‌های NoSQL رتبه چهارم را در رضایت مشتری و حضور در مارکت را بر اساس نظرات کاربران به خود اختصاص داده است و به عنوان محبوب‌ترین پایگاه داده‌ی NoSQl در container ها انتخاب شده‌است.
طبق آمارهای سایت Stackoverflow نیز ، Redis مورد علاقه ترین پایگاه داده  برنامه نویسان در سال‌های ۲۰۱۷ تا ۲۰۲۰ بوده‌است.


##  تفاوت Redis با سایر سیستم‌های پایگاه داده‌ 

Redis ایده سیستمی را رایج کرد که می تواند همزمان یک محل ذخیره‌سازی و یک حافظه پنهان باشد ، با استفاده از طرحی که در آن داده ها در حافظه اصلی رایانه اصلاح می شوند و از آن خوانده میشوند ، اما همچنین بر روی دیسک با قالبی که برای دسترسی تصادفی به داده مناسب نیست ذخیره میشوند ، اما فقط پس از راه اندازی مجدد سیستم ، داده ها را دوباره در حافظه بازسازی می کنیم.
 در همان زمان ، Redis یک مدل داده را ارائه می دهد که در مقایسه با سیستم مدیریت پایگاه داده رابطه ای (RDBMS) بسیار غیر معمول است. دستورات کاربر به صورت کوئری که باید توسط موتور پایگاه داده اجرا شود توصیف نمی شوند بلکه به شکل عملیات خاصی که بر روی داده های abstract انجام می شود ، توصیف می کنند. از این رو ، داده ها باید به روشی ذخیره شوند که بعداً برای بازیابی سریع مناسب باشد  بدون کمک از سیستم پایگاه داده به صورت ایندکس های ثانویه ، تجمع یا سایر ویژگی های مشترک RDBMS قدیمی. 
در پیاده سازی Redis از فراخوان سیستمی fork استفاده زیادی می شود ، تا پردازه ای که داده‌ها را  نگهداری می‌کند کپی کند و پردازه والد همچنان به سرویس دهی به client ادامه دهد ، در حالی که فرآیند فرزند نسخه ای از داده ها را بر روی دیسک ایجاد می کند.


## زبان‌های پشتیبانی شده
از نسخه 2.6 ،   Redis از امکان اسکریپت نویسی سمت سرور به زبان Lua برخوردار است.
بسیاری از زبان‌های برنامه نویسی دارای Redis language bindings در سمت کلاینت خود می‌باشند. زبان‌هایی که برای آن‌ها کتابخانه کلاینت ردیس وجود دارد عباتند از:
اکشن‌اسکریپت، سی، سی++، سی شارپ، کلوژر، لیسپ معمولی، دارت، ارلنگ، گو، هسکل، هکس، آی‌او، جاوا، جاوااسکریپت، لوا، آبجکتیو-سی، پرل، پی‌اچ‌پی، پیور داتا، پایتون، آر، روبی، اسکالا، اسمال‌تاک، تی‌سی‌ال. چندین برنامه نرم افزاری کلاینت در این زبانها وجود دارد.

## انواع داده‌ها
redis نگاشتی از کلیدها به مقدارها است. تفاوت مهم بین Redis و سایر سیستم های ذخیره سازی ساختاری این است که Redis نه تنها از رشته ها (Strings) ، بلکه از انواع داده های انتزاعی (abstract) نیز پشتیبانی می کند.
 نوع داده مقدار عملیات ممکن بر روی هر کلید را مشخص می‌کند. ردیس از انواع داده زیر پشتیبانی می‌کند:
رشته: رشته‌ها می‌توانند هر نوع داده‌ای، مثلاً تصویر باینری، را نگهداری کنند. یک رشته باید حداکثر ۵۱۲ مگابایت طول داشته باشد.
لیست: لیست‌ها لیست‌های از رشته‌ها هستند که به ترتیب درج مرتب شده‌اند. می‌توان به سر یا ته یک لیست یک عنصر جدید افزود.
مجموعه: مجموعه‌ها کلکسیون بدون ترتیبی از رشته‌ها هستند. می‌توان به یک مجموعه رشته جدید افزود، حذف کرد، یا وجود یک رشته را در مجموعه امتحان کرد.
درهم‌سازی(Hash): درهم‌سازی‌های ردیس نگاشتی بین کلیدهای از نوع رشته به مقادیر از نوع رشته‌است.
مجموعه مرتب: مشابه مجموعه‌ها هستند، با این تفاوت که به هر عنصر مجموعه مرتب یک امتیاز تخصیص می‌یابد، و اعضای مجموعه مرتب از بیشترین امتیاز به کمترین امتیاز مرتب می‌شوند.

## ماندگاری داده‌ها
redis چندین مدل مختلف برای ماندگاری داده‌ها ارائه می‌دهد:
* ذخیره‌کردن یک نسخه از داده بر روی دیسک در بازه‌های منظم طبق قواعدی که توسط کاربر مشخص شده‌است.
* ثبت در شرح وقایع (log) پس از دریافت هر درخواست نوشتن، که این شرح وقایع را در اجرای دوباره بعدی سرور می‌توان مجدد اجرا کرد.
* غیرفعال کردن ماندگاری
* ترکیبی از دو حالت اول
در حالت دوم، یعنی ثبت رخدادها در شرح وقایع (log)، چندین گزینه وجود دارد:
* هماهنگ‌کردن حالت فایل با حالت فیزیکی دیسک به محض عمل نوشتن (امن‌ترین گزینه، ولی کندترین)
* هماهنگ‌کردن حالت فایل با حالت فیزیکی دیسک در هر یک ثانیه (امکان از دست دادن حداکثر یک ثانیه داده)
* محول کردن هماهنگ‌کردن حالت فایل با حالت فیزیکی دیسک به سیستم‌عامل (تندترین گزینه، ولی ناامن‌ترین)

## عملکرد 

در شرایطی که مانایی داده‌ها نیاز نباشد، ویژگی in-memory بودن redis باعث می‌شود کارایی و performance بالاتری نسبت به دیتابیس هایی که هر تغییر را در حافظه اعمال نموده، داشته باشد. ردیس تنها روی یک پردازه عمل میکند و بر روی فایل های append-only روی دو پردازه عمل میکند. در نتیجه یک واحد ردیس نمی تواند عملیات‌ها را به صورت موازی اجرا کند.

## خوشه بندی 

ردیس خوشه بندی را در آوریل ۲۰۱۵ با انتشار ورژن 3.0 معرفی کرد. مشخصه خوشه، مجموعه‌ای از دستورات ردیس را پیاده سازی می‌کند: تمام دستورات تک کلیدی قابل دسترس هستند، دستورات چند کلیدی (دستورات مربوط به اجتماع‌ها و اشتراک‌ها) محدود به کلید‌های متعلق به نود‌های یکسان می‌باشند و دستورات مربوط به عملیات selection دیتابیس در دسترس نمی باشند. یک خوشه ردیس می‌تواند تا ۱۰۰۰ گره، ایمنی نوشتاری قابل قبول داشته باشد و در صورت خرابی برخی از گره‌ها  عملیات را ادامه دهد. 

## موارد استفاده    

با توجه به ماهیت طراحی دیتابیس، موارد استفاده معمولا عبارتند از ذخیره session، 
حافظه پنهان، صف های پیغام و سایر موارد. شرکت‌های بزرگی مانند توییتر از ردیس استفاده می‌کنند. سرویس وب آمازون، مایکروسافت و 
Alibaba
، 
استفاده از ردیس را در مجموعه‌های خود پیشنهاد می‌کنند
.

## آموزش نصب 

در این قسمت آموزش نصب Redis 5.0.x بر روی سیستم‌ عامل Ubuntu 20.04 را بررسی می‌کنیم.

برای نصب دستورات زیر را وارد می‌کنیم:


>>>>>>> ceab26348c14de4009c285d2c3b5ce69bacca0c0

<div dir="ltr">

```
<<<<<<< HEAD
GET server:blabla
    => nil
=======
sudo apt update
sudo apt install redis-server
>>>>>>> ceab26348c14de4009c285d2c3b5ce69bacca0c0
```

</div>

<<<<<<< HEAD
برای اینکه بررسی کنیم آیا یک کلید مقدار دهی شده است یا خیر، میتوانیم از دستور زیر استفاده کنیم.

<div dir="ltr">

```
EXISTS server:name
    => 1
```

```
EXISTS server:blabla
    => 0
```

</div>

میتوانیم برای حذف یک کلید مقداردهی شده، از دستور زیر استفاده کنیم.
=======



پس از پایان نصب ، سرویس Redis به طور خودکار آغاز می‌شود. برای مشاهده وضعیت سرویس از دستور زیر استفاده می‌کنیم:

>>>>>>> ceab26348c14de4009c285d2c3b5ce69bacca0c0

<div dir="ltr">

```
<<<<<<< HEAD
DEL server:name
=======
sudo systemctl status redis-server
>>>>>>> ceab26348c14de4009c285d2c3b5ce69bacca0c0
```

</div>

<<<<<<< HEAD
مشابه اکثر زبان های برنامه نویسی، دستوری برای اضافه کردن به مقدار یک کلید عددی و کم کردن از کلید عددی، به طور خاص اضافه کردن یک واحد و کم کردن یک واحد در ردیس داریم. نکته حائز اهمیت، Thread Safe بودن این دستور ها است که جلوتر توضیح خواهیم داد.

اضافه کردن یک واحد:

<div dir="ltr">

```
INCR server:name
```

</div>

اضافه کردن به میزان دلخواه:
=======


خروجی مانند زیر باید باشد:


>>>>>>> ceab26348c14de4009c285d2c3b5ce69bacca0c0

<div dir="ltr">

```
<<<<<<< HEAD
INCRBY server:name 100
=======
redis-server.service - Advanced key-value store
     Loaded: loaded (/lib/systemd/system/redis-server.service; enabled; vendor preset: enabled)
     Active: active (running) since Sat 2020-06-06 20:03:08 UTC; 10s ago
...
>>>>>>> ceab26348c14de4009c285d2c3b5ce69bacca0c0
```

</div>

<<<<<<< HEAD
کم کردن یک واحد:

<div dir="ltr">

```
DECR server:name
```

</div>

کم کردن به میزان دلخواه:
=======

اکنون Redis برای سیستم عامل نصب می‌باشد. ولی به طور خودکار Redis اتصالات remote را نمی‌پذیرد و تنها از localhost ( جایی که Redis اجرا میشود) می‌توان به آن متصل شد بنابراین برای اینکه بتوان به صورت remote هم متصل شد باید آن را تنظیم کنیم:

ابتدا فایل configure را با دستور زیر باز کنید:

>>>>>>> ceab26348c14de4009c285d2c3b5ce69bacca0c0

<div dir="ltr">

```
<<<<<<< HEAD
DECRBY server:name 100
=======
sudo nano /etc/redis/redis.conf
>>>>>>> ceab26348c14de4009c285d2c3b5ce69bacca0c0
```

</div>

<<<<<<< HEAD
با یک مثال این را توضیح می دهیم.

<div dir="ltr">

```
SET open_connections 0
INCR open_connctions
    => 1
INCR open_connctions
    => 2
INCR open_connctions
    => 3
INCRBY open_connctions 100
    => 103
DECRBY open_connctions 23
    => 80
```

</div>

شاید تصور کنید که مزیت استفاده از این دستور ها، تنها در سادگی نوشتار است. به عنوان مثال ممکن است دو قطعه کد زیر را معادل بدانید.

<div dir="ltr">

```
INCR open_connctions
```

```
x = GET connections
x = x + 1
SET connections x
=======
خطی که با bind 127.0.0.1 ::1 شروع میشود را پیدا کرده و کامنت کنید. 


 
<div dir="ltr">

```
#bind 127.0.0.1 ::1
>>>>>>> ceab26348c14de4009c285d2c3b5ce69bacca0c0
```

</div>

<<<<<<< HEAD
در حالت تک کاربره، این دو دستور درواقع معدل یک دیگر عمل می کنند.
اما در صورتی که برنامه ما multi-client باشد. ممکن است همزمانی منجر به ایجاد نتیجه نامطلوب شود.
به عنوان مثال فرض کنید که دو کلایت A و B داریم.
کلاینت A می خواهد یک واحد به connections اضافه کند و کلاینت B میخواهد یک واحد کم کند.
از آنجایی که توابع INCR و DECR همزمانی را نمی پذیرند، این کار در صورت استفاده از این توابع بدون مشکل انجام خواهد شد.
اما اگر از قطعه کد دوم استقاده کنیم. هممانی اجرای Thread ها میتواند مشکل ساز شود.

<div dir="ltr">

```
SET c 1                         // c  == 1
A executes: x1 = GET c          // x1 == 1
B executes: x2 = GET c          // x2 == 1
A executes: x1 = x1 + 1         // x1 == 2
B executes: x2 = x2 - 1         // x2 == 0
A executes: SET c x1            // c  == 2
B executes: SET c x2            // c  == 0, Confilict: expected 1 got 0
```

</div>

توجه کنید که مثال فوق تنها یک ترتیب فرضی مشکل ساز بود.
برنامه های چند رشته ای بدون هیچ ترتیب خاصی اجرا میشوند.

ممکن است بخواهیم از ردیس به عنوان یک cache مدت دار استفاده کنیم یا به هر دلیل دیگری، بخواهیم که داده ای که در ردیس ذخیره می کنیم، پس از مدتی منقضی و از حافظه حذف شود.
در این صورت می توانیم از دستور های زیر استفاده کنیم.

برای اینکه زمان انقضا برا یک داده مربوط به یک کلید استفاده کنیم می توانیم از دستور EXPIRE استفاده کنیم. مقیاس زمانی این دستور ثانیه است.
=======
توجه : در صورتی که client ای که به پایگاه داده متصل میشود روی همان سیستمی که host قرار دارند، نباید این کار را انجام دهید!

سپس فایل را ذخیره کرده و با دستور زیر سرویس Redis را آپدیت کنید.


>>>>>>> ceab26348c14de4009c285d2c3b5ce69bacca0c0

<div dir="ltr">

```
<<<<<<< HEAD
SET temp 1
EXPIRE temp 10
=======
sudo systemctl restart redis-server
>>>>>>> ceab26348c14de4009c285d2c3b5ce69bacca0c0
```

</div>

<<<<<<< HEAD
اگر بخواهیم در زمان مقدار دهی نیز میتوانیم مستقیما این کار را به این صورت انجام دهیم.

<div dir="ltr">

```
SET temp 1 EX 10
```

</div>

اگر بخواهیم میتوانیم به جای EXPIRE از PEXPIRE برای زمان دهی در مقیاس میلی ثانیه استفاده کنیم.
=======
سپس با دستور زیر می‌توان مطمئن شد که Redis بر روی تمام interface  های پورت مورد نظر(در اینجا 6379) در حال listen است:

>>>>>>> ceab26348c14de4009c285d2c3b5ce69bacca0c0

<div dir="ltr">

```
<<<<<<< HEAD
SET temp 1
PEXPIRE temp 10000
=======
ss -an | grep 6379
>>>>>>> ceab26348c14de4009c285d2c3b5ce69bacca0c0
```

</div>

<<<<<<< HEAD
با استفاده از دستور TTL میتوانیم زمان باقی مانده به منقضی شدن یک داده را استخراج کنیم.
از دستور PTTL نیز میتوانیم برای استحراج این مقدار در مبنای میلی ثانیه استفاده کنیم.

<div dir="ltr">

```
SET temp 1 EX 10
// after 2s
TTL temp                => 8
// after 9s
TTL temp                => -2
```

```
SET permant 2
TTL temp                => -1
```

</div>

عدد منفی دو به این معنی است که این کلید تعریف نشده است.
عدد منفی یک به این معنی است که این کلید منقضی نمیشود و در حال حاضر دائمی است.

توجه کنید که برای یک کلید، می توانیم یک کلید را از طریق دستور PERSIST دائمی کنیم.
=======

خروجی دستور مشابه زیر هست که در آن 0.0.0.0 بیانگر آدرس‌های IPv4 هست.


>>>>>>> ceab26348c14de4009c285d2c3b5ce69bacca0c0

<div dir="ltr">

```
<<<<<<< HEAD
SET temp 1 EX 10
PRESIST temp
TTL temp                => -1
=======
tcp  LISTEN 0   511   0.0.0.0:6379   0.0.0.0:*
tcp  LISTEN 0   511      [::]:6379      [::]:* 
>>>>>>> ceab26348c14de4009c285d2c3b5ce69bacca0c0
```

</div>

<<<<<<< HEAD
## داده ساختار ها در ردیس

در ردیس داده ساختار های متعددی وجود دارد. چند مورد از این داده ساختار ها و دستورات مربوط به آن را به اختصار معرفی خواهیم کرد.

### لیست (list)

لیست یک توالی ترتیب دار از المان های است.
دستورات اصلی داده ساختار لیست عبارتند از:

با استفاده از این دستور به سر سمت راست لیست، عنصر اضافه میشود.
پاسخ این دستور طول لیست پس از عملیات خواهد بود.
=======
 در قدم بعدی باید تنظیمات firewall خود را به گونه قرار دهید که ترافیک‌های TCP در پورت 6379 را فعال کند.
 (مطمئن شید که firewall شما اتصالات معتبر و بدون خطری رو قبول کند)
معمولا میخوایم که IP address های خاصی اجازه دسترسی به سرور Redis داشته باشند، مثلا اگر بخواهیم فقط اتصالاتی که از زیرشبکه‌ی 192.168.121.0/24 هستند دسترسی داشته باشند ، دستور زیر را اجرا میکنیم:

>>>>>>> ceab26348c14de4009c285d2c3b5ce69bacca0c0

<div dir="ltr">

```
<<<<<<< HEAD
RPUSH
```

```
> RPUSH mylist Aryan
1
> RPUSH mylist Avina
2
```

</div>

با استفاده از این دستور به سر سمت چپ لیست، عنصر اضافه میشود.
پاسخ این دستور طول لیست پس از عملیات خواهد بود.
=======
sudo ufw allow proto tcp from 192.168.121.0/24 to any port 6379
```

</div>
 
 
 الان شما می‌توانید یک اتصال TCP روی پورت 6379 به Redis از remote connections داشته باشید.
 
اگر خواستید مطمئن بشید که همه چی به درستی تنظیم شده کافی است  سرور Redis در ماشین remote را با دستور زیر ping کنید:
>>>>>>> ceab26348c14de4009c285d2c3b5ce69bacca0c0

<div dir="ltr">

```
<<<<<<< HEAD
LPUSH
```

```
> LPUSH mylist Hamid
1
=======
redis-cli -h <REDIS_IP_ADDRESS> ping
>>>>>>> ceab26348c14de4009c285d2c3b5ce69bacca0c0
```

</div>

<<<<<<< HEAD
توجه کنید که با اولین باری که یک تابع لیستی را بر روی یک کلید آزاد صدا کنید، مقدار آن کلید تعریف به عنوان لیست تعریف میشود.

با استفاده از این دستور میتوانیم طول لیست را دریافت کنیم.

<div dir="ltr">

```
LLEN
```

```
> RPUSH mylist Aryan
1
> RPUSH mylist Avina
2
> LLEN mylist
2
> LPUSH mylist Hamid
3
> LLEN mylist
3
```

</div>

با استفاده از این دستور میتوانیم عناصر قرار گرفته بین دو ایندکس را دریافت کنیم.
به عنوان ورودی این دستور دو عدد دریافت می شود که اولی به معنای شروع بازه و دومی به معنی پایان بازه میباشد.
هر دو ایندکس شروع و پایان در نتیجه نهایی قرار میگیرند.
توجه کنید که ایندکس گذاری در این داده ساختار نیز مشابه اکثر زبان های برنامه نویسی از صفر است.
بنابرین یک لیست n تایی از صفر تا n-1 ایندکس بندی میشود. همچنین مکمل دهم هر ایندکس نیز معادل همان ایندکس خواهد بود.
به عبارت دیگر عناصر متناظرا از 1- تا n- از انتهای لیست ایندکس بندی میشوند. بنابرین هر دو ایندکس n-1 و 1-، اشاره به عنصر آخر لیست دارند.
=======

دستور باید خروجی زیر را نشان دهد:

 

>>>>>>> ceab26348c14de4009c285d2c3b5ce69bacca0c0

<div dir="ltr">

```
<<<<<<< HEAD
LRANGE
```

```
> RPUSH mylist Aryan
1
> RPUSH mylist Avina
2
> LPUSH mylist Sara
3
> LPUSH mylist Hamid
4
> LRANGE mylist 1 3
1) "Sara"
2) "Aryan"
3) "Avina"
> LRANGE mylist 0 2
1) "Hamid"
2) "Sara"
3) "Aryan"
> LRANGE mylist 0 3
1) "Hamid"
2) "Sara"
3) "Aryan"
4) "Avina"
> LRANGE mylist 0 -1
1) "Hamid"
2) "Sara"
3) "Aryan"
4) "Avina"
> LRANGE mylist 1 -2
1) "Sara"
2) "Aryan"
=======
PONG
>>>>>>> ceab26348c14de4009c285d2c3b5ce69bacca0c0
```

</div>

<<<<<<< HEAD
با استفاده از این دو دستور، عنصر سر راست یا جپ لیست حذف و برگردانده میشود.

<div dir="ltr">

```
RPOP
```

```
LPOP
```

```
> RPUSH mylist Aryan
1
> RPUSH mylist Avina
2
> LPUSH mylist Sara
3
> LPUSH mylist Hamid
4
> LRANGE mylist 0 -1
1) "Hamid"
2) "Sara"
3) "Aryan"
4) "Avina"
> LPOP mylist
Hamid
> RPOP mylist
Avina
> LRANGE mylist 0 -1
1) "Sara"
2) "Aryan"
```

</div>

در نهایت توجه شما را به variadic بودن دستورات PUSH جلب می کنم. به این صورت که همزمان چند عنصر را می توان با استفاده از این دستور به لیست اضافه کرد.
=======
## برخی دستورات  پرکاربرد

در این قسمت برخی دستورات پرکاربرد redis را بررسی می کنیم.

* برای ذخیره مقادیر درون کلید ها از دستور set استفاده می شود:
>>>>>>> ceab26348c14de4009c285d2c3b5ce69bacca0c0

<div dir="ltr">

```
<<<<<<< HEAD
> RPUSH mylist Hamid Sara Aryan Avina
> LRANGE mylist 0 3
1) "Hamid"
2) "Sara"
3) "Aryan"
4) "Avina"
=======
set num 2
>>>>>>> ceab26348c14de4009c285d2c3b5ce69bacca0c0
```

</div>

<<<<<<< HEAD
### مجموعه (Set)

یک داده ساختار معروف دیگر در ردیس، مجموعه است. مزیت مجموعه این است که با سرعت بسیار بالا می توان بررسی کرد که آیا
یک المان در آن وجود دارد یا خیر. توجه کنید که همانند تعریف ریاضی مجموعه، ترتیب خاصی در مجموعه حاکم نیست و المان ها به ترتیب شبه تصادفی در مجموعه قرار می گیرند.

دستورات مجموعه عبارتند از:

با استفاده از این دستور میتوانیم یک عنصر به مجموعه اضافه کنیم. مشابه لیست این دستور نیز میتواند چند ورودی همزمان دریافت کند.

<div dir="ltr">

```
SADD
```

```
> SADD airlines "Iran Air"
1
> SADD airlines "Lufthansa" "British Airways" "United Airliens"
4
```

</div>

با استفاده از دستور زیر می توانیم المانی را از لیست حذف کنیم. توجه کنید پاسخ این دستور صفر و یک است. اگر صفر باشد، یعنی اصلا این عنصر وجود نداشته و تغییری در لیست نیز ایجاد نشده است.
اگر یک باشد به این معنی است که آن المان وجود داشته و حذف شده است. توجه کنید که تکرر در مجموعه معنی ندارد و یک عنصر یا وجود دارد یا ندارد. یک عنصر نمی تواند دوبار در یک مجموعه باشد.
=======
این دستور مقدار ۲ را در کلید num ذخیره می‌کند.

* برای برگرداندن مقدار درون کلید مورد نظر از دستور get استفاده می شود:
>>>>>>> ceab26348c14de4009c285d2c3b5ce69bacca0c0

<div dir="ltr">

```
<<<<<<< HEAD
SREM
```

```
> SADD airlines "Iran Air" "Lufthansa" "British Airways" "United Airliens"
3
> SREM airlines "Lufthansa"
1
> SREM airliens "Lufthansa"
0
=======
get num
>>>>>>> ceab26348c14de4009c285d2c3b5ce69bacca0c0
```

</div>

<<<<<<< HEAD
با استفاده از دستور زیر، میتوانیم وجود یا عدم وجود یک المان را در مجموعه بسنجیم.

<div dir="ltr">

```
SISMEMBER
```

```
> SADD airlines "Iran Air" "Lufthansa" "British Airways" "United Airliens"
3
> SISMEMBER airlines "Lufthansa"
1
> SISMEMBER airlines "Air France"
0
```

</div>

با استفاده از دستور زیر، می توانید تمام اعضای یک مجموعه را دریافت کنید. توجه کنید که ترتیب خاصی در برگرداندن اعضا وجود ندارد.
=======
و خروجی مقدار ۲ را برمی گرداند.

* برای تست وجود کلید از دستور EXISTS استفاده می شود:
>>>>>>> ceab26348c14de4009c285d2c3b5ce69bacca0c0

<div dir="ltr">

```
<<<<<<< HEAD
SMEMBERS
```

```
> SADD airlines "Iran Air" "Lufthansa" "British Airways" "United Airliens"
3
> SISMEMBERS airlines
1) Lufthansa
2) British Airways
3) Iran Air
4) United Airliens
=======
EXISTS num     => 1
EXISTS blabla  => 0
>>>>>>> ceab26348c14de4009c285d2c3b5ce69bacca0c0
```

</div>

<<<<<<< HEAD
با استفاده از دستور `SRANDMEMBER` میتوانید یک عنصر رندم را از مجموعه دریافت کنید. در صورتی که نیاز به چند عدد رندم دارید. میتوانید تعداد مورد نیاز را به عنوان پارامتر ورودی به این تابع بدهید.
=======
* برای اضافه کردن مقدار عددی درون یک کلید می توان از دستور INCR و یا INCRBY استفاده کرد:
>>>>>>> ceab26348c14de4009c285d2c3b5ce69bacca0c0

<div dir="ltr">

```
<<<<<<< HEAD
SRANDMEMBER
```

```
> SADD airlines "Iran Air" "Lufthansa" "British Airways" "United Airliens"
3
> SRANDMEMBER airlines
"Lufthansa"
> SRANDMEMBER airlines 2
1) "British Airways"
2) "Iran Air"
=======
INCR num
>>>>>>> ceab26348c14de4009c285d2c3b5ce69bacca0c0
```

</div>

<<<<<<< HEAD
در صورتی که میخواهید عناصر خروجی گرفته شده از دستور `SRANDMEMBER` حذف شود، میتوانید به جای این دستور از دستور زیر استفاده کنید.
=======
پس از این دستور مقدار درون کلید num به صورت اتمیک ۳ می شود.
>>>>>>> ceab26348c14de4009c285d2c3b5ce69bacca0c0

<div dir="ltr">

```
<<<<<<< HEAD
SPOP
```

```
> SADD airlines "Iran Air" "Lufthansa" "British Airways" "United Airliens"
3
> SPOP airlines 2
1) "British Airways"
2) "Iran Air"
> SMEMBERS airlines
1) Lufthansa
=======
INCRBY num 100 
>>>>>>> ceab26348c14de4009c285d2c3b5ce69bacca0c0
```

</div>

<<<<<<< HEAD
### مجموعه مرتب (Sorted List)

مجموعه های مرتب مشابه مجموعه های عادی هستند. با این تفاوت که در تناظر با هر عنصر یک امتیاز عددی قرار می گیرد که مبنای مرتب‌سازی عناصر خواهد بود. این داده ساختار با `Z` مشخص می شود.
برای یادگیری این داده ساختار، کافی است که به دستورات لیست و مجموعه مسلط باشید.
مثال:

<div dir="ltr">

```
> ZADD hackers 1940 "Alan Kay"
1
> ZADD hackers 1906 "Grace Hopper"
1
> ZADD hackers 1953 "Richard Stallman"
1
> ZADD hackers 1965 "Yukihiro Matsumoto"
1
> ZADD hackers 1916 "Claude Shannon"
1
> ZADD hackers 1969 "Linus Torvalds"
1
> ZADD hackers 1957 "Sophie Wilson"
1
> ZADD hackers 1912 "Alan Turing"
1
> ZRANGE hackers 2 4
1) "Claude Shannon", 2) "Alan Kay", 3) "Richard Stallman"
=======
 و پس از دستور بالا مقدار num به ۱۰۳ تغییر خواهد کرد.
 
* همانند این دو دستور برای کم کردن مقادیر مورد نظر نیز وجود دارد:
 
 <div dir="ltr">

```
DECR   num      => 102
DECRBY num 100  => 2
>>>>>>> ceab26348c14de4009c285d2c3b5ce69bacca0c0
```

</div>

<<<<<<< HEAD
یکی از کاربرد های این داده ساختار در رتبه بندی اعضای یک بازی است. این موضوع را جلوتر توضیح دادیم و در آنجا در مجموعه مرتب عمیق‌تر شده ایم.

### هش (Hash)

هش یک مپ بین کلید ها و مقادیر رشته ای یا عددی است.
با استفاده از دستور `HSET` میتوانیم به هر کلید یک مقدار نسبت بدهیم.
مقدار خروجی مشابه مجموعه است. اگر آن کلید قبلا مقدار دهی نشده باشد 1 و در غیر این صورت صفر خواهد بود.

<div dir="ltr">

```
HSET
```

```
> HSET user:1000 name "John Smith"
1
> HSET user:1000 email "john.smith@example.com"
1
> HSET user:1000 password "s3cret"
1
```

</div>

همچنین می توانیم با استفاده از دستور زیر مقدار نسبت داده شده به یک کلید را استخراج کنیم.
=======
همچنین این دستورات نیز مانند تمامی دستورات ردیس اتمیک عمل میکنند.

* برای حذف کلید و مقدار کلید مورد نظر از دیتابیس از دستور DEL میتوان استفاده کرد:
>>>>>>> ceab26348c14de4009c285d2c3b5ce69bacca0c0

<div dir="ltr">

```
<<<<<<< HEAD
HGET
```

```
> HSET user:1000 name "John Smith"
1
> HSET user:1000 email "john.smith@example.com"
1
> HSET user:1000 password "s3cret"
1
> HGET user:1000 name
"John Smith"
=======
DEL num
>>>>>>> ceab26348c14de4009c285d2c3b5ce69bacca0c0
```

</div>

<<<<<<< HEAD
همچنین می تونیم با استفاده از دستور زیر همزمان چند کلید را مقداردهی کنیم.
=======
* ردیس می تواند تنظیم شود تا یک کلید را تنها برای مدت مشخصی نگه دارد. این کار با استفاده از دستورات TTL و EXPIRE می‌تواند انجام شود:
>>>>>>> ceab26348c14de4009c285d2c3b5ce69bacca0c0

<div dir="ltr">

```
<<<<<<< HEAD
HMSET
```

```
> HMSET user:1001 name "Mary Jones" password "hidden" email "mjones@example.com"
OK
> HGET user:1002 name
"Mary Jones"
=======
EXPIRE num 120
>>>>>>> ceab26348c14de4009c285d2c3b5ce69bacca0c0
```

</div>

<<<<<<< HEAD
همچنین با استفاده از دستور زیر می توانیم که تمامی کلید های مقدار دهی شده ی یک هش را دریافت کنیم.

<div dir="ltr">

```
HGETALL
```

```
> HMSET user:1001 name "Mary Jones" password "hidden" email "mjones@example.com"
OK
> HGETALL user:1001
1) "name"
2) "Mary Jones"
3) "password"
4) "hidden"
5) "email"
6) "mjones@example.com"
```

</div>

توجه کنید که برای مقادیر عددی، دستورات INCR و ... به صورت atomic وجود دارند. لزوم استفاده از این دستورات را پیشتر توضیح دادیم.
=======
با این دستور کلید num و مقدارش فقط برای ۱۲۰ ثانیه نگه داری می‌شوند و سپس حذف می شوند.

با استفاده از دستور TTL نیز می‌توان مدت زمان باقی مانده تا حذف یک کلید را به دست آورد:
>>>>>>> ceab26348c14de4009c285d2c3b5ce69bacca0c0

<div dir="ltr">

```
<<<<<<< HEAD
HINCRBY
```

```
> HMSET user:1002 name "Aryan" sessions 1
OK
> HINCRBY user:1002 sessions 1
2
> HINCRBY user:1002 sessions 1
3
=======
TTL num => 115
>>>>>>> ceab26348c14de4009c285d2c3b5ce69bacca0c0
```

</div>

<<<<<<< HEAD
## بهینه‌سازی مموری

### ذخیره بهینه داده ساختارهای کوچک

از نسخه 2.2 ردیس تا به حال بسیاری از داده‌ساختار ها به صورت ویژه بهینه‌سازی شده‌اند تا به ازای حجم مشخصی از داده از فضای کمتری استفاده کنند. برای مثال داده ساختار‌های هش، لیست، مجموعه و ... که تنها از اعداد صحیح تشکیل شده‌اند، هنگامی که داری اعضای کمتری نسبت به یک حد ماکسیمم باشند، به صورت فوق بهینه شده در مموری ذخیره می‌شوند. به طوری که به طور میانگین تا 5 برابر بهینه تر و در بعضی مواقع تا 10 برابر بهینه تر از حالت عادی عمل می‌کنند.
از آن‌جا که این عمل یک تریدآف سی‌پی‌یو و مموری است، کنترل کامل این ویژگی را می‌توانیم در دست بگیریم. برای مثال در قطعه کد زیر تمام وِیژگی های موجود را بنابر صلاحدید خود کانفیگ کرده‌ایم.
=======
همچنین می‌توان تنظیم مقدار برای یک کلید و تنظیم TTL برای آن را در یک دستور مانند زیر انجام داد:
>>>>>>> ceab26348c14de4009c285d2c3b5ce69bacca0c0

<div dir="ltr">

```
<<<<<<< HEAD
hash-max-ziplist-entries 512
hash-max-ziplist-value 64
zset-max-ziplist-entries 128
zset-max-ziplist-value 64
set-max-intset-entries 512
=======
SET num 2 EX 5
>>>>>>> ceab26348c14de4009c285d2c3b5ce69bacca0c0
```

</div>

<<<<<<< HEAD
اگه هر کدام از داده‌ها یا داده‌ساختار ها ار حد ماکسیمم مجاز تجاور کنند، آن‌گاه ردیس به صورت خودکار آن را به روش عادی انکود خواهد کرد.

### استفاده از نسخه 32 بیتی

ردیس طراحی شده برای نسخه 32 بیتی مقدار قابل توجه کمتری مموری مصرف می‌کند. اما استفاده از آن مارا محدود به استفاده از ماکسیمم 4 گیگابات از مموری می‌کند. برای اجرای ردیس به عنوان به طور 32 بیتی باید از دستور make 32bit استفاده کنیم. فایل های RDB و AOF با هر دو نسخه 32 بیتی و 64 بیتی سازگارند و شما می‌توانید هر کدام را به نسخه دلخواه تغییر دهید.

### استفاده از هش

هش های کوچک فضای بسیار کمی را اشغال می‌کنند. پس شما باید تا حد امکان داده خود را با استفاده از هش ارائه کنید. برای مثال به جای استفاده از کلیدهای متعدد برای ذخیره اطلاعات یک کاربر کافیست هش‌ مرتبط به آن را دخیره کنید.

## استفاده از ردیس به عنوان یک LRU Cache

وقتی ردیس به عنوان یک کش استفاده می‌شود، رایج است که به آن اجازه دهیم که به صورت خودکار داده‌های قدیمی را با ورود داده‌های جدید حذف کند. این رفتار در جامعه توسعه دهندگان شناخته شده است زیرا این رفتار رد واقع رفتار پیشفرض memcached system است.
در واقع LRU تنها یکی از متدهای حذف داده پشتیبانی شده است. در ادامه در مورد بحث جامع تری به نام maxmemory صحبت خواهیم کرد.

### تعیین کردن ماکسیمم مموری

از این دستور برای تعیین کردن میزان حداکثری استفاده از مموری استفاده می‌شود. برای انجام این امر می‌توان دستوری به شکل زیر را در فایل redis.conf بیارویم.

<div dir="ltr">

`maxmemory 100mb`

</div>

ست کردن این مقدار به صفر بدان معناست که هیچ محدودیتی برای استفاده از مموری وجود ندارد. زمانی که مموری پر شده می‌توانیم از یکی از سیاست های حذف ذکر شده در زیر استفاده کنیم تا بخشی از داده‌های قدیمی پاک شود.

### سیاست های حذف داده

رفتاری که ردیس در هنگام رسیدن به حد بیشنه تعیین شده انجام می‌دهد به کانفیگ نوشته شده در maxmemory-policy وابسته است.
روش های گوناگون حذف داده قدیمی عبارتند از :

-   noevictation : هنگامی که مموری به بیشینه مقدار مجاز می‌رسد خطا بر می‌گرداند.
-   allkeys-lru : داده‌ها را به ترتیب استفاده اخیر آن ها به صورت صعودی حذف می‌کند.
-   volatile-lru : مشابه روش قبل است با این تفاوت که فقط بر کلیدهای دارای expire set تاثیر دارد.
-   allkeys-random : به طور تصادفی کلید های را حذف می‌کند تا فضا برای داده‌های جدید ایجاد شود.
-   volatile-random : مشابه روش قبل است با این تفاوت که فقط بر کلیدهای دارای expire set تاثیر دارد.
-   volatile-ttl : کلید های با expire set را حذف می‌کند. در این روش کلیدهای با عمر کوتاه تر حذف می‌شوند.

تمامی روش های ذکر شده در صورت برآورده نشدن شرایط اولیه مانند noevication عمل می‌کنند.

انتخاب سیاست حذف مناسب بستیگ به پترن طراحی اپلیکیشن ما دارد. هر چند ردیس امکان دوباره کانفیگ کردن این سیاست ها در هر زمان را فراهم کرده است.

### فرایند حذف

درک چگونگی اجرای فرآیند حذف حائذ اهمیت بالایی است.این فرآیند به شکل زیر کار می‌کند :

-   کاربر دستوری را اجرا می‌کند و در نتیجه داده جدید به وجود می‌آید.
-   ردیس میزان استفاده از مموری را ارزیابی می‌کند و اگر از مقدار معین تعیین شده بیشتر بود با توجه به سیاست انتخاب شده شروع به حذف داده‌های قبلی می‌کند.
-   دستور جدیدی اجرا می‌شوند و این عمل تکرار می‌شود

### الگوریتم تقریبی LRU

این الگوریتم پیاده‌سازی دقیقی ندارد. این بدین معناست که ردیس توانایی انتخاب بهترین نامزد برای حذف شدن را ندارد و در عوض از نسخه تقریبی الگوریتم LRU استفاده می‌کند. در این روش دسته کوچکی از کلیدها انتخاب شده و بهترین نامزد از میان آن‌ها انتخاب می‌شود.
در نسخه های اخیر بهینه‌سازی هایی انجام شده است که نتایج بدست آمده را به نتیجه حاصل از اجرای دقیق این الگوریتم نزدیک‌تر می‌کند.
همچنین شما می‌توانید اندازه دسته‌های انتخاب شده را تعیین کنید. بدین منظور از دستوری مشابه دستور زیر در فایل کانفیگ استفاده می‌کنیم.

<div dir="ltr">

`maxmemory-samples 5`

</div>

دلیل استفاده نشدن از نسخه دقیق این الگوریتم این است که موجب استفاده از مموری بیشتری می‌شود. هر چند که نتایج تا حدی خوبی نزدیک به هم است. تصویر زیر تفاوت عملکرد این دو نسخه از الگوریتم را نمایان می‌کند.

<img src="https://redis.io/images/redisdoc/lru_comparison.png" alt="LRU comparison">

-   خاکستری روشن : کلیدهایی که حذف شده‌اند
-   طوسی : کلیدهایی که حذف نشده‌اند
-   سبز : کلیدهایی که اضافه شده‌اند

### متد جدید LFU

همزمان با عرضه نسخه 4 ردیس متد جدیدی به عنوان گزینه ای برای جایگزینی متد قبل عرضه شد که در موقعیت‌های مشخصی بهتر عمل می‌کند. در این متد کلیدهایی که به ندرت استفاده می‌شوند حذف می‌شوند و کلیدهایی که مدام مورد استفاده قرار می‌گیرند شانس بیشتری برای بقا دارند.
مشکل موجود در الگوریتم LRU این است که ممکن است در گروه انتخاب شده کلیدی وجود داشته باشد که به تازگی اضافه شده باشد و به همین خاطر تا به حال درخواست نشده است و این الگوریتم به اشتباه آن را پاک می‌کند. اما الگوریتم LFU این مشکل را ندارد و به طوری کلی در پترن های طراحی متفاوت بهتر تطابق می‌یابد.
برای پیاده‌سازی LFU متد های زیر قابل دسترس است :

-   volatile-lfu : کلید های دارای expire set را با اجرای الگوریتم تقریبی LFU حذف می‌کند.

-   allkeys-lfu : الگوریتم را بر کل کلیدها اجرا می‌کند و اقدام به حذف کلیدهای برگزیده می‌کند.

لازم به ذکر است الگوریتم LFU نیز همانند LRU دقیق نیست و یک الگوریتم تقریبی است. این الگوریتم از یک شمارنده احتمالی به نام شمارنده موریس استفاده می‌کند تا میزان تکرر استفاده از هر کلید را تنها در چند بیت تخمین بزند. همچنین دوره نزولی وجود دارد که پس از مدت معینی این شماره را کاهش می‌دهد. زیرا از بعد زمان مشخصی دیگر نمی‌خواهیم بعضی از کلیدها را به عنوان "اخیرا دیده شده" داشته باشیم. حتی اگر در گذشته جزو این دسته بوده‌اند.

به طور پیشفرض ردیس 4 تنظیم شده است که :

-   شمارنده را بعد از حدود یک میلیون درخواست بروزرسانی کند.
-   با گذشت هر دقیقه شمارنده را کاهش دهد.

این دو متغیر به صورت منطقی انتخاب شده اند اما اگه کاربر بخواهد می‌تواند آن‌ها را دست‌خوش تغییرات کند.
=======
با دستور persist نیز می‌توان زمان باقی مانده برای یک کلید را کنسل کرد:
>>>>>>> ceab26348c14de4009c285d2c3b5ce69bacca0c0

<div dir="ltr">

```
<<<<<<< HEAD
lfu-log-factor 10
lfu-decay-time 1
=======
PERSIST num
TTL num => -1
>>>>>>> ceab26348c14de4009c285d2c3b5ce69bacca0c0
```

</div>

<<<<<<< HEAD
| factor | 100 hits | 1000 hits | 100K hits | 1M hits | 10M hits |
| ------ | -------- | --------- | --------- | ------- | -------- |
| 0      | 104      | 255       | 255       | 255     | 255      |
| 1      | 18       | 49        | 255       | 255     | 255      |
| 10     | 10       | 18        | 142       | 255     | 255      |
| 100    | 8        | 11        | 49        | 143     | 255      |

پس به زبان ساده factor یک تریدآف میان متمایز شدن بین داده هایی که کمتر فراخوانده شده‌اند و متمایز شدن بین داده‌هایی که بیشتر فراخوانده شده‌اند است.

## کشینگ سمت کلاینت

این روش یک تکنیک است که به منظور پیاده‌سازی سرویس‌های با قدرت اجرای بالا استفاده می‌شود. در این روش زیرمجموعه از اطلاعات موقتا به صورت مستقیم در سمت کلاینت ذخیره می‌شود.
معمولا هنگامی که یک داده مورد نیاز است، سرورهای اپلیکیشن آن داده را از دیتابیس درخواست می‌کنند. (مانند شکل زیر)

<div dir="ltr">

```
+-------------+                                +----------+
|             | ------- GET user:1234 -------> |          |
| Application |                                | Database |
|             | <---- username = Alice ------- |          |
+-------------+                                +----------+
```

</div>

اما وقتی از کشینگ سمت کلاینت استفاده می‌کنیم، اپلیکیشن پاسخ‌های پرطرفدار کوئری را مستقیما در سمت کلاینت ذخیر می‌کند تا بتوواند بعدا از آن استفاده کند بدون آنکه بخواهد به دیتابیس متصل شود.
=======
* برای استفاده از list در ردیس کافی است از دستورات RPUSH، LPUSH، LLEN، LRANGE، LPOP، RPOP استفاده کرد. بدون اینکه دستوری برای ایجاد یک لیست استفاده شود می توان ازین دستورات برای اولین بار با کلیدی که قبلا با تایپ دیگر موجود نبوده استفاده کرد.


دو دستور RPUSH و LPUSH به‌ترتیب به انتها و ابتدای لیست مقدار اضافه میکنند: 
>>>>>>> ceab26348c14de4009c285d2c3b5ce69bacca0c0

<div dir="ltr">

```
<<<<<<< HEAD
+-------------+                                +----------+
|             |                                |          |
| Application |       ( No chat needed )       | Database |
|             |                                |          |
+-------------+                                +----------+
| Local cache |
|             |
| user:1234 = |
| username    |
| Alice       |
+-------------+
=======
RPUSH friends "Alice"
RPUSH friends "Bob"
LPUSH friends "Sam"
>>>>>>> ceab26348c14de4009c285d2c3b5ce69bacca0c0
```

</div>

<<<<<<< HEAD
این نوع پیاده‌سازی سرعت انجام این عملیات را تا حد قابل توجهی اقزایش می‌دهد.

به طور کلی دو مزیت عمده کشینگ سمت کلاینت عبارت‌اند از :

-   دادهدر کمترین زمان در دسترس است
-   دیتابیس کوئری‌های کمتری دریافت می‌کند که در نتیجه باعث می‌شود به دیتاست مشابه با تعداد کمتری از node پاسخ بدهد.

### پیاده‌سازی ردیس از کشینگ سمت کلاینت

به طور کلی کشینگ سمت کلاینت دو حالت مختلف در ردیس دارد.

-   در حالت پیشفرض، سرور به یاد می‌آورد که کلاینت داده شده به کدام کلیدها دسترسی پیدا کرده‌است و هنگامی که یک کلید مشابه تنظیم می‌شود خطای نامعتبر پس می‌دهد.

-   در حالت برداکستینگ سرور این‌ها را به یاد نمی‌آورد و در واقع مموری از سمت سرور استفاده نمی‌شود و در عوض به روش دیگر این اطلاعات در سمت کلاینت ذخیره ‌می‌شود.

## استفاده از ردیس در رتبه بندی بازی ها

یکی از مهم ترین ویژگی های بازی های آنلاین و رقابتی ، جدول امتیازات آنهاست که به کاربر این اجازه را می دهد تا بتواند عملکرد خودش را با دیگر کاربران مقایسه کند و در نتیجه برای ایجاد فضای رقابتی و کشش کاربران به بازی بیشتر ، واجب است.

یکی از کاربرد‌های پایگاه داده redis در بحث جدول امتیازات (leaderboard) بازی های آنلاین است. در واقع در صورتی که تعداد کاربران همچنان کم باشد و میلیونی نشده باشد ، دیتابیس های relational یا sql می توانند در این امر به ما کمک کنند ؛ اما با افزایش تعداد کاربران ، مشکلاتی پدید می‌آید که از آنها می توان به موارد زیر اشاره کرد:

- بدیهی ترین مشکل ، زمان درخواست و query است که به دلیل تعداد بالای کاربران ، هر query ممکن است چندین ثانیه یا حتی چند ده ثانیه طول بکشد.

- دومین مشکل ، محاسبه رتبۀ هر بازیکن است که برای این کار به صورت real time مجبوریم ، جایگاه تمامی کاربران دیگر را در جدول محاسبه کنیم.

- برای داشتن جدول ، پایگاه داده باید به صورت مداوم ، عملیات اضافه و حذف کاربر ، بروزرسانی امتیاز ، محاسبۀ رتبه و ... را انجام دهد که این کار در دیتابیس های relational ، به صورت بهینه قابل انجام نیست و سربار اضافی روی سرور ایجاد می کند.

- از آنجایی که در این بازی ها ، به صورت لحظه ای ، درخواست خواندن از پایگاه داده ممکن است فرستاده شود ، پایگاه داده های relational ، نمی توانند این درخواست های با فرکانس زیاد را مدیریت کنند.

در نتیجۀ موارد گفته شده ، به راحتی می توان نتیجه گرفت گه برای پیاده‌سازی جدول امتیازات، پایگاه داده های non-relational یا no sql مانند redis می توانند مناسب باشند ، زیرا این نوع پایگاه داده ها ، بیشتر برای کار با داده های بدون ساختار و حجیم طراحی شده اند.

همان طور که در بخش های قبل دیدیم ، redis ، با استفاده از ram برای ذخیره و نگهداری داده ها ، سرعت بسیار بالایی دارد که این اولین نکتۀ مثبت این پایگاه داده است که سبب می شود در شرایطی که لود و فشار بالایی وجود دارد ، همچنان از سرعت بهره‌ مند باشیم. دیگر نکتۀ مثبت این پایگاه داده ، داده ساختار های منحصر به فرد آن است که دربارۀ آنها در بخش های قبلی صحبت کرده ایم. قابل حدس است که به خاطر ویژگی مقایسه ای و صعودی بودن جدول امتیازات ، sorted set این پایگاه داده می تواند در پیاده‌سازی جدول امتیازات به ما کمک کند.

### نکات استفاده از مجموعه مرتب

می‌دانیم که این داده ساختار در redis همانند set ها هستند و اعضای غیرتکراری از جنش رشته دارند، با این تفاوت که برای مرتب‌سازی، هر عضو این داده ساختار، یک ویژگی امتیاز هم دارد که این اعضا توسط این امتیاز‌ ها مرتب‌سازی می شوند. تفاوت مهم این داده ساختار با پایگاه داده های Relational، در این است که عملیات های حذف و اضافه و بروزرسانی در این داده ساختار، به نحوی است، در هر عملیات، عضو مربوطه دقیقا در جای خودش قرار می گیرد و این مرتب‌سازی که به نوعی پیش پردازش می شود، در هنگامی که می خواهیم به کاربران، رتبۀ آنها و جدول را به صورت real-time نشان دهیم، باعث افزایش سرعت عملیات می شود.

از نکات مهم و کلیدی این داده ساختار، می توان به این اشاره کرد که در این داده ساختار، می توان به راحتی در میان اعضا، عضو اضافه یا حذف کرد و همچنین محاسبۀ رتبه، به دلیل مرتب بودن اعضا، به راحتی امکان‌پذیر است. این ویژگی ها باعث شده که این داده ساختار، بتواند درخواست های زیاد یک جدول امتیازات را، به سرعت جواب دهد، بنابراین در پیاده‌سازی به کمک ما می آید. در جدول زیر می توانید اردر انجام عملیات های مهم و کلیدی این داده ساختار را مقایسه کنید.

<div dir="ltr">

|                             | List      | HashSet   | SortedSet |
| --------------------------- | :-------: | :-------: | :-------: |
| Iteration                   | O(n)      | O(n)      | O(n)      |
| Search                      | O(n)      | O(1)      | O(n)      |
| Add                         | O(n)      | O(1)      | O(lg n)   |
| Remove                      | O(n)      | O(1)      | O(lg n)   |
| Enumerating in sorted order | O(n lg n) | O(n lg n) | O(n)      |
| Allow duplicate             | Yes       | No        | No        |
</div>

دستورات کاربردی sorted set برای پیاده‌سازی جدول امتیازات به شرح زیر هستند:

این دستورات روی مجموعه `ZSET` عملیات انجام می دهند.

`ZADD` این دستور برای اضافه کردن اعضای جدید و امتیاز آنها به مجموعه استفاده می شود و در صورتی که مجموعه ای نباشد ، یک مجموعۀ جدید با این اعضا می سازد.

`ZREM` از این دستور برای حذف اعضا استفاده می شود.

`ZRANGE` برای گرفتن مجموعه اعضای `ZSET` که در یک بازۀ ورودی از رتبه ها قرار دارند، استفاده می شود.

`ZRANGEBYSCORE` یک مجموعه از اعضا را بر می گرداند که امتیاز آنها در بازۀ خاصی از امتیازات باشد.

`ZCOUNT` تعداد اعضای مجموعه را بر می گرداند که امتیاز آنها در بازآ مینیمم تا ماکزیمم داده شده باشد.

`ZRANK` رتبۀ عضوی که به عنوان ورودی گرفته را بر می گرداند.

`ZSCORE` امتیاز عضو را خروجی می دهد.

`ZINCRBY` این تابع، امتیاز عضوی که به عنوان ورودی گرفته است را افزایش می دهد.

حال با توجه به دستورات فوق، شمای کلی ساختار پیاده شده برای جدول امتیازات، معلوم می شود.

به این شکل که در بازی ، برای هر عضو جدید که وارد رقابت می شود یا برای هر کاربری که به طور کلی از رقابت خارج می شود، از دستورات `ZADD` و `ZREM` برای اضافه کردن و حذف کردن به جدولمان استفاده می کنیم.

پس از هر رقابت، برای بروزرسانی کل جدول، کافی است، از دستور `ZINCRBY` و `ZRANK` به ازای هر کاربر استفاده کنیم تا اولا، امتیاز کاربر را در دیتابیس، بروزرسانی کنیم و سپس رتبۀ تغییر پیدا کرده را بگیریم و به کاربر نمایش دهیم.

از دستورات `ZCOUNT`، `ZRANGE` و `ZRANGEBYSCORE` نیز می توان برای پیدا کردن اعضایی که می خواهیم در جدول نمایش دهیم استفاده کنیم. به عنوان مثال اگر بخواهیم، 20 نفر اول را نمایش دهیم و سپس با کمی فاصله ، رتبۀ کاربر و اعضایی که با کاربر، امتیاز مشترک دارند را نمایش دهیم، کافی است اولا با `ZRANGE`، 20 عضو در بازۀ 1 تا 20 را بگیریم و سپس با `ZSCORE`، امتیاز کاربر را بگیریم و نهایتا با استفاده از `ZRANGEBYSCORE`، کاربران دیگری که امتیازشان در بازۀ خاصی حول امتیاز این کاربر هستند را بگیریم و نمایش دهیم.

در نمونه های زیر، مثال هایی از استفاده دستورات قابل مشاهده است:

<div dir="ltr">

```
> ZADD sectionA:history 70 ali 80 hasan 90 mohammad
3
```
</div>

مثال بالا، یک مجموعه می سازد و 3 عضو با نمره های آنها را به آن اضافه می کند.
=======
دستور LRANGE زیرمجموعه ای از مقادیر لیست را خروجی می‌دهد. این دستور ایندکس ابتدایی و انتهایی لیست مطلوب را به عنوان پارامتر دریافت می‌کند:
>>>>>>> ceab26348c14de4009c285d2c3b5ce69bacca0c0

<div dir="ltr">

```
<<<<<<< HEAD
> ZRANGEBYSCORE sectionA:history 0 50
(empty)
```
</div>

مثال بالا، مجموعه ای از دانش آموزان (داده ها) را بر میگرداند که نمرۀ آنها بین 0 تا 50 است.

<div dir="ltr">

```
> ZRANGE sectionA:history 0 10 WITHSCORES
1) ali
2) 70
3) hasan
4) 80
5) mohammad
6) 90
```
</div>

مثال بالا، مجموعه ای از دانش آموزان را بر می گرداند که رتبۀ بین 0 تا 10 را داشته باشند.
=======
LRANGE friends 0 1   => 1) "Sam", 2) "Alice"
```

</div>

دو دستور LPOP و RPOP به ترتیب از ابتدا و انتهای لیست مقداری را حذف کرده و خروجی می‌دهند:
>>>>>>> ceab26348c14de4009c285d2c3b5ce69bacca0c0

<div dir="ltr">

```
<<<<<<< HEAD
> ZSCORE sectionA:history ali
70
```
</div>

مثال بالا، نمرۀ دانش آموزی که به عنوان ورودی داده شده را بر میگرداند.

<div dir="ltr">

```
> ZCOUNT sectionA:history 0 85
2
```
</div>

مثال بالا، تعداد افرادی را بر می گرداند که نمرۀ آنها بین 0 تا 85 شده باشد.
=======
LPOP friends => "Sam"
RPOP friends => "Bob"
```

</div>

و در آخر دستور LLEN نیز طول لیست را خروجی می‌دهد:
>>>>>>> ceab26348c14de4009c285d2c3b5ce69bacca0c0

<div dir="ltr">

```
<<<<<<< HEAD
> ZRANK sectionA:history hasan
1

> ZRANK sectionA:history ali
0
```
</div>

مثال بالا، رتبۀ هر دانش آموزی که به عنوان ورودی داده می شود را بر می گرداند.

<div dir="ltr">

```
> ZINCRBY sectionA:history 5 ali
75
```
</div>

مثال بالا، نمرۀ دانش آموز ورودی را به مقدار 5 تا افزایش می دهد.


<div dir="ltr">

```
> ZREM sectionA:history ali
1
```
</div>

مثال بالا، دانش آموز ورودی را به طور کلی از مجموعه حذف می کند.

### جمع‌بندی

به طور کلی دیدیم که برای جدول امتیازات، وقتی تعداد کاربر بالا می رود، از آنجایی که محاسبۀ رتبۀ کاربر، یک درخواست تو در تو (nested) است که باعث می شود اردر زمانی محاسبۀ رتبه، به صورت مربعی باشد و به طور میانگین برای 50 میلیون عضو، حدود 35 ثانیه طول بکشد که این تجربۀ کاربر را خراب می کند و آزار دهنده است. همچنین از آنجایی که این جدول به صورت مدام در حال تغییر است و نتایج به صورت real-time به کاربر نشان داده می شود، استفاده از cache نمی تواند راهگشای مشکل باشد. بنابراین استفاده از دیتابیس های relational ، باعث ایجاد بار اضافی محاسباتی روی سرور می شود و در نتیجه کل عملیات را کند می کند.

در نتیجۀ مشکلات و چالش های به وجود آمده، دنبال راه حلی بودیم که اولا به ازای هر تعداد کاربر و درخواست، عملکرد پایدار و قابل پیشبینی داشته باشد و ثانیا بتواند به سرعت و به آسانی عملیات های نسبی جدول امتیازات، مانند گرفتن اعضای درون یک بازه یا در یک محدودۀ رتبه و ... را انجام دهد.

در نهایت به راه حل استفاده از redis رسیدیم که با داشتن داده ساختار های منحصر به فرد در پیش پردازش و کم کردن بار محاسباتی سرور کمک می کند و به دلیل ساختار خاصی که دارد و استفاده از ram برای ذخیرۀ داده ها ، مشکل سرعت را حل می کند.

نهایتا پیاده‌سازی های مورد نیاز بررسی شد که به طور خلاصه، می تواند موارد زیر را شامل شود:

- redis server این مرحله، پیاده‌سازی داده ساختار اصلی و سرور redis برای کار کردن با این پایگاه داده است.

- sorted set در این مرحله دیدیم که با استفاده از sorted set و بهره بردن از مزایای خاص این داده ساختار می توانیم، مرتب‌سازی کاربران بر اساس امتیاز آنها را به صورت یک پیش پردازش داشته باشیم که در هر لحظه بتوان درخواست ها را به سرعت جواب داد. همچنین با استفاده از این داده ساختار، عملیات هایی مانند پیدا کردن کاربران در یک بازۀ رتبه یا پیدا کردن کاربران در یک بازۀ امتیاز و ... به راحتی قابل انجام است که این امر در نمایش یک جدول پویا و دلخواه به ما کمک می کند.

- different sorted sets پیاده‌سازی این مورد دلخواه است اما به عنوان مثال در مواردی که می خواهیم چند مدل نمایش از جدول داشته باشیم، کاربرد دارد. به عنوان مثال، ترتیب جدول می تواند برعکس باشد یا حتی در یک بازی خاص، به جای اینکه نفرات اول نمایش داده شوند، فقط 10 نفر بالاتر و پایین‌تر از هر کاربر نشان داده شوند یا به طور کلی هر مدل خاصی از ترتیب و نمایش که مد نظر است، می تواند به صورت یک مجموعه جدا پیاده شود.

- redis hash data structure این مورد بیشتر در مواردی به درد می خورد که درخواست ها مربوط به اطلاعات کاربران باشد و شاید در مواردی، پیاده‌سازی آن لزومی نداشته باشد اما داشتن یک جدول با اطلاعات کامل تر برای هر کاربر، ممکن است نیاز به این ساختار نیز داشته باشد.

- sets operations طبیعتا برای استفاده مجموعه ها، مجبوریم عملیات های مورد نیازی که به صورت آماده وجود ندارند را پیاده کنیم تا در صورت نیاز بتوانیم عملیات خاص مربوط به مجموعه ها را انجام دهیم. این عملیات ها در پیاده‌سازی جدول پیشرفته‌تر یا کامل تر می توانند کمک کنند. به عنوان مثال می توان عملیات اجتماع، اشتراک، متمم و ... در مجموعه ها را پیاده کرد در صورت لزوم برای نمایش حالت های خاص رتبه بندی از آنها استفاده کرد.
=======
LLEN friends => 1
```

</div>

</div>

<div dir="rtl">
  
## کاربردها 

برخی از رایج ترین موارد استفاده Redis عبارت از:
*  حافظه نهان نشست (Session Cache)

یکی از کاربرد‌های مهم redis استفاده از آن به عنوان حافظه نهان نشست (session cache) می‌باشد. مزیت استفاده از redis نسبت به دیگر ابزارهای ذخیره نشست، ماندگاری آن است. همچنین دسترسی به اسناد مربوط به چگونگی استفاده از Redis برای این منظور بسیار آسان است.
*  کش کامل صفحه (Full Page Cache (FPC))

Redis یک پلت فرم FPC ارائه می‌دهد که کار کردن با آن بسیار آسان است. بازگشت به سازگاری (consistency) ، حتی در زمان شروع مجدد  Redis instanceها، به همراه ماندگاری دیسک ، باعث می‌شود کاربران شما متوجه هیچ کاهش سرعتی در زمان بارگذاری صفحه خود نشوند.
* صف‌ها (Queues)

استفاده از Redis در موتور ذخیره سازی حافظه (memory storage engine) برای انجام عملیات مربوط به لیست‌ها و مجموعه‌ها (set) ، آن را به یک بستر شگفت انگیز برای استفاده در صف پیام (message queue) تبدیل می کند. تعامل با Redis به عنوان یک صف ، برای هر کسی که عادت به استفاده از عملیات push / pop لیست ها در زبان های برنامه نویسی مانند پایتون دارد، آسان می‌باشد.
* شمارش و تابلو‌ها (Leaderboards/Counting)

به دلیل in-memory بودن redis ، عملیات increment و decrement به وسیله آن به سادگی و به شکل کارایی صورت می‌گیرد. همچنین ساختمان داده‌های مجموعه و مجموعه مرتب را نیز پشتیبانی می‌کند که ساختمان داده‌های پرکاربردی هستند.
* استفاده از فیچر Pub/Sub

از این این فیچر ردیس در ارتباطات شبکه های اجتماعی، راه اندازی اسکریپت های مبتنی بر رویدادهای Pub / Sub و سیستم های چت استفاده می‌شود .
>>>>>>> ceab26348c14de4009c285d2c3b5ce69bacca0c0

</div>


<div dir="rtl">
<h2> RedisBloom </h2>
ردیس علاوه بر داده ساختار‌های گفته شده داده ساختار‌های احتمالی را نیز برای ما فراهم می‌کند.
این داده ساختار‌ها علاوه بر کاهش استفاده از مموری هزینه‌های CPU و ... را نیز کاهش می‌دهد.
<br>
این داده ساختار‌ها قرار است به سوالاتی مشخص برای داده‌های ما پاسخ دهند.
از این داده‌ساختار‌ها برای پاسخ به سوالات زیر استفاده می‌کنیم:
<ul>
    <li>HyperLogLog: چه تعداد مقدار یکتا در دیتاست خود داریم</li>
    <li>Bloom filter و Cuckoo filter: آیا یک مقدار خاص در دیتاست ما وجود دارد یا خیر</li>
    <li>Count-min sketch: چند بار یک مقدار خاص در دیتاست ما وجود دارد</li>
    <li>Top-K: در دیتاست ما k تعداد از مقادیر بیشتر از همه وجود دارند این مقادیر کدام‌ها هستند.</li>
</ul>

برای پاسخ به سوالات بالا باید از مقدار زیادی مموری استفاده کنیم.
برای همین از داده‌ساختار‌های احتمالی استفاده می‌کنیم.
در این صورت دقت خود را کم می‌کنیم ولی از مموری خیلی کمتر 
برای این مورد استفاده می‌کنیم.
> تفاوت بین Bloom و Cuckoo بین این است که 
> Bloom در داده‌ها با حجم بسیار بالا و عملکرد بهتری دارد و اسکیل‌پذیر‌تر است
> در حالی که Cuckoo سریعتر بوده و همچنین امکان حذف داده‌ها را به ما می‌دهد همچنین قابلیت ساخت باکت برای داده‌های خود دارد..

ردیس به کمک داده ساختار‌های خود به ما کمک می‌کند که به این سوالات پاسخ دهیم، در ادامه به معرفی چند 
دستور می‌پردازیم:

</div>

<h3>
Bloom Filter
</h3>


<div dir="rtl">
ساخت یک دیتاست از نوع Bloom.
پارامتر‌های ورودی:

- key نام دیتاست
- error_rate مشخص می‌کند تا چه اندازه می‌توانیم خطا داشته باشیم.
- capacity تعداد المان‌هایی که می‌توانند به دیتاست اضافه شوند.

پارامتر‌های اختیاری:

- NONSCALING اجازه نمی‌دهد تا اگر ظرفیت پر شد باز آیتمی به دیتاست اضافه شود.
- EXPANSION زمانی که ظرفیت دیتاست پر شد یک sub-filter جدید می‌سازد. ظرفیت این sub-filter برابر با <code>expansion</code> برابر ظرفیت sub-filter قبلی خواهد.

</div>

```bash
BF.RESERVE key error_rate capacity [EXPANSION expansion] [NONSCALING]
```

<div dir="rtl">
اضافه کردن یک آیتم به دیتاست. 
</div>

```bash
BF.ADD key item
```


<div dir="rtl">
اضافه کردن چند آیتم به دیتاست. 
</div>

```bash
BF.MADD key item [item ...]
```


<div dir="rtl">
چک کردن اینکه یک آیتم در دیتاست وجود دارد یا خیر
در صورت وجود داشتن خروجی برابر با <code>1</code> و در غیر  اینصورت برابر با <code>0</code>
است.
</div>

```bash
BF.EXISTS key item
```



<div dir="rtl">
همان دستور <code>BF.EXISTS</code>
است صرفا با این تفاوت که خروجی‌های
<code>0</code> و
<code>1</code>
رابه ترتیب نشان می‌دهد.
</div>

```bash
BF.MEXISTS key item [item ...]
```


<div dir="rtl">
این دستور ترکیب دو دستور 
<code>BF.RESERVE</code> و
<code>BF.ADD</code>
می‌باشد. در صورتی که این دیتاست با این نام وجود نداشته باشد
آن را می‌سازد.
تا آرگومان
<code>ITEMS</code>
همان ورودی‌های 
<code>BF.RESERVE</code>
است و پس از آن آیتم‌های دیتاست را اضافه می‌کنیم.

توجه کنید آرگومان
<code>NOCREATE</code>
در صورتی که چنین دیتاستی وجود نداشته باشد آن را نمی‌سازد
و ردیس به ما ارور می‌دهد.
</div>

```bash
BF.INSERT key [CAPACITY capacity] [ERROR error]
  [EXPANSION expansion] [NOCREATE] [NONSCALING] ITEMS item [item
  ...]
```



<h3>
Cuckoo Filter
</h3>

<div dir="rtl">
ساخت یک دیتاست از نوع Cuckoo.
پارامتر‌های ورودی:

- key نام دیتاست
- capacity تعداد المان‌هایی که می‌توانند به دیتاست اضافه شوند.

> ظرفیت به توان nام بعدی ۲ گرد می‌شود


پارامتر‌های اختیاری:

- bucketsize بتعداد آیتم‌ها را در هر باکت مشخص می‌کند. هر چه سایز بیشتر باشد با اینکه fill rate بیشتری خواهیم داشت ولی همچنین از نظر پرفورمنسی و همچنین افزایش ارور ریت منجر می‌شود.
- maxiterations تعداد تلاش‌ها برای swap کردن آیتم‌ها بین باکت‌ها قبل از اینکه بخواهد بگوید آیا این دیتاست ما پر شده است یا خیر. مقدار کمتر این پارامتر برای ما پرفورمنس بهتری خواهد داشت.
- expansion همانند expansion در Bloom عمل می‌کند با همان شرطی که به توان nام بعدی ۲  رند می‌کند. 
</div>

```bash
CF.RESERVE key capacity [BUCKETSIZE bucketsize] [MAXITERATIONS maxiterations] [EXPANSION expansion]
```


<div dir="rtl">
یک آیتم را به دیتاست ما اضافه می‌کند.
</div>

```bash
CF.ADD key item

```
<div dir="rtl">
تعداد یک آیتم در دیتاست ما را مشخص می‌کند.
</div>

```bash
CF.COUNT key item
```

<div dir="rtl">
یک آیتم را از دیتاست ما حذف می‌کند.
</div>

```bash
CF.DEL key item
```

<div dir="rtl">
مانند 
<code>BF.EXISTS</code>
است
</div>

```bash
CF.EXISTS key item
```

<div dir="rtl">
مانند 
<code>BF.MEXISTS</code>
است

</div>

```bash
CF.MEXISTS key item [item ...]
```

<h3 dir="rtl"> 
تست چند دستور
</h3>

<div dir="rtl">
در این قسمت چند دستور از Bloom Filter ردیس را تست می‌کنیم:
</div> 

```bash
 127.0.0.1:6379> BF.ADD bloom kirk
 1) (integer) 1
 127.0.0.1:6379> BF.ADD bloom redis
 1) (integer) 1
 127.0.0.1:6379> BF.EXISTS bloom kirk
 (integer) 1
 127.0.0.1:6379> BF.EXISTS bloom redis
 (integer) 1
 127.0.0.1:6379> BF.EXISTS bloom nonexist
 (integer) 0
 127.0.0.1:6379> BF.EXISTS bloom que?
 (integer) 0
 127.0.0.1:6379>
 127.0.0.1:6379> BF.MADD bloom elem1 elem2 elem3
 1) (integer) 1
 2) (integer) 1
 3) (integer) 1
 127.0.0.1:6379> BF.MEXISTS bloom elem1 elem2 elem3
 1) (integer) 1
 2) (integer) 1
 3) (integer) 1
```

<div dir="rtl">
همچنین می‌توانید دیتا‌ست‌ها و فیلتر‌های مخصوص به خودتان را نیز بسازید.
</div> 

```bash
 127.0.0.1:6379> BF.RESERVE largebloom 0.0001 1000000
 OK
 127.0.0.1:6379> BF.ADD largebloom kirk
 1) (integer) 1
  127.0.0.1:6379> BF.ADD largebloom redis
 1) (integer) 1
 127.0.0.1:6379> BF.EXISTS largebloom kirk
 (integer) 1
 127.0.0.1:6379> BF.EXISTS largebloom redis
 (integer) 1
 127.0.0.1:6379> BF.EXISTS largebloom nonexist
 (integer) 0

```

<div dir="rtl">
حال چند دستور دیگر را بررسی می‌کنیم:
</div> 

```bash
127.0.0.1:6379> BF.MEXISTS largebloom redis nonexist
1) (integer) 1
2) (integer) 0
```

<div dir="rtl">
در این قسمت چند دستور از Cuckoo Filter ردیس را تست می‌کنیم:
</div> 


```bash
127.0.0.1:6379> CF.ADD newcuckoo redis
(integer) 1
127.0.0.1:6379> CF.EXISTS newcuckoo redis
(integer) 1
127.0.0.1:6379> CF.COUNT newcuckoo redis
(integer) 1
127.0.0.1:6379> CF.EXISTS newcuckoo notpresent
(integer) 0
127.0.0.1:6379> CF.MEXISTS newcuckoo redis notpresent
1) (integer) 1
2) (integer) 0
127.0.0.1:6379> CF.DEL newcuckoo redis
(integer) 1
127.0.0.1:6379> CF.EXISTS newcuckoo redis
(integer) 0
127.0.0.1:6379> CF.COUNT newcuckoo redis
(integer) 0
```

> توضیحات این دستورات در قسمت‌های قبلی مشخص هستند و همچنین عملکرد هر کدام توضیح داده شده‌اند.


<p align="center">
    <img src="https://github.com/AryanAhadinia/web_workshop/blob/redis_article/Redis/public/redis_logo.svg" alt="Redis Logo">
</p>

<p align="center">
    نویسندگان: پریا حاجی‌پور، علیرضا امیری، امیررضا قدیانی
</p>

# ردیس
## مقدمه
ردیس یک سیستم مدیریت پایگاه داده و حافظه نهان نمایه‌ای (in-memory) است که تاکید بزرگی بر سرعت و عملکرد دارد. در این README، به بررسی ویژگی‌ها، مثال‌ها، کاربردها، آزمون و مقایسه با دیگر سیستم‌های مدیریت داده خواهیم پرداخت.

## ویژگی‌ها
**سرعت بالا:** ردیس به عنوان یک سیستم نهان نمایه‌ای، اطلاعات را در حافظه ذخیره کرده و به دسترسی سریع به داده‌ها امکان می‌دهد.

**پشتیبانی از داده‌های مختلف:** از رشته‌ها گرفته تا داده‌های ساختاری مثل لیست و مجموعه، ردیس انعطاف پذیری زیادی در ذخیره و بازیابی داده فراهم می‌کند.

**پشتیبانی از توزیع:** ردیس می‌تواند به عنوان یک سیستم توزیع شده عمل کند و از طریق شبکه به چندین نود متصل شود.

**پشتیبانی از زبان‌های مختلف:** پشتیبانی کامل از زبان های برنامه نویسی مختلف که برای تمامی آنها کتابخانه های متعدد وجود دارد.
از معروفترین زبان های که از ردیس پشتیبانی به عمل می آورند می توان به Bash, C, C#, C++, Go, java, Matlab, node.js, Perl, PHP, Ruby, Swift, Python, VB و ... اشاره کرد.

## مزایا
**رایگان و کدباز**

**سادگی در استفاده**

**ماندگاری (persistence): اطلاعات شما در اثر ریستارت سرور از بین نمی رود!**

**پشتیبانی از Replication: ردیس به خوبی از Replication پشتیبانی میکند شما میتوانید سرورهای مختلفی را به صورت Master/Slave یا سناریوهای دلخواه خود اجرا کنید.**

**استفاده از طیف وسیعی از ساختمان داده ها (Data Type)**

**سرعت پاسخدهی فوق العاده**

## معایب

درست است که Redis با استفاده از ساختار In-Memory یا مقیم در حافظه کار می کند که باعث سرعت دسترسی و پاسخدهی بسیار عالی می گردد اما حافظه Ram در سرورها و سرورهای ابری (Cloud) معیار اصلی قیمت گذاری است و پردازنده و هارد دیسک در معیارهای بعدی هستند.
در نتیجه نیاز زیاد Redis به حافظه می تواند گرانقیت باشد البته درست است که Redis قابلیت استفاده از Virtual momory را دارد اما منجر به استفاده شدید I/O هارد دیسک می شود.

البته این موارد را نیز می توان با استفاده از Raid های سخت افزاری و دیسک های پرسرعت جامد مانند SSD,NVME برطرف نمود.

## ساختمان داده ها(Data types):
ردیس یک دیتابیس کلید / مقدار است اما این مقدار قرار نیست همیشه یک رشته string باشد ردیس از پنج نوع داده پشتیبانی می کند :

**رشته(String):**
رشته ها میتوانند هر نوع داده ای باشند یک رشته حداکثر از 512 مگابایت پشتیبانی می کند.

**لیست(Lists):**
لیست ها در واقع مجموعه ای از رشته ها هستند که به ترتیب درج مرتب شده اند میتوان به اول یا انتهای لیست یک عنصر جدید اضافه کرد.

**مجموعه(Set):**
مجموعه در واقع کلکسیون بدون ترتیب از رشته ها هستند میتوان در یک مجموعه رشته جدید اضافه یا حذف یا جستجو کرد.

**مجموعه مرتب(Sorted Set):**
همانند مجموعه است با این تفاوت که به هر عنصر مجموعه مرتب یک امتیاز تخصیص می یابد.

**هش(Hash):**
هَش در واقع نگاشتی بین کلید و مقدار است و یک رشته جدید بین آن ها قرار می دهد که برای دسترسی به مقدار نیاز به کلید و هش به صورت همزمان است.

## کاربردها
ردیس برای کاربردهای متنوعی مورد استفاده قرار می‌گیرد:

**حافظه نهان داده:** ذخیره سازی اطلاعات در حافظه به منظور دسترسی سریع. 
یکی از کاربردهای اصلی Redis، استفاده به عنوان حافظه نهان داده (Data Cache) است. با ذخیره اطلاعات در حافظه به جای دیسک، Redis امکان دسترسی به سریعترین حد ممکن به داده‌ها را فراهم می‌کند. این مورد بسیار مفید است زمانی که نیاز به دسترسی سریع به داده‌هایی است که فرکانس استفاده بالا دارند، مثل نتایج کوئری‌های پرس و جو یا محاسبات مکرر.

**سیستم صف:** برای مدیریت صف‌ها و پردازش داده‌ها به ترتیب ورود. 
Redis به خوبی می‌تواند به عنوان یک سیستم صف (Queue) برای مدیریت وظایف در صف استفاده شود. وظایف می‌توانند به ترتیب ورود به صف اضافه شده و از سرور Redis با استفاده از دستورات مخصوص مدیریت صف (مانند LPUSH و RPUSH) بازیابی و پردازش شوند. این کاربرد بسیار مناسب برای مواقعی است که نیاز به مدیریت ترتیب و اجرای مستقل وظایف دارید.

**آگاهی از تغییرات:**  ذخیره و بازیابی تغییرات در داده‌ها برای اعلان‌ها و رصد. 
Redis می‌تواند به عنوان یک سیستم اعلان (Pub/Sub) نیز استفاده شود. در این حالت، یک مشترک می‌تواند به یک یا چند کانال مشترک شده و اطلاعات مربوط به تغییرات یا رویدادها را دریافت کند. این کاربرد بسیار مفید در مواردی است که نیاز به آگاهی فوری از تغییرات داده‌ها دارید، مثل نظارت بر تغییرات در داده‌های زمان واقعی یا اطلاع‌رسانی به کاربران.

**مدیریت جلسات:** 
Redis می‌تواند به عنوان یک سیستم مدیریت جلسات (Session Management) نیز استفاده شود. با ذخیره اطلاعات جلسات کاربران در حافظه، این سیستم می‌تواند به سرعت اطلاعات لاگین، حالت و دیگر اطلاعات مرتبط با جلسه را بازیابی کند. این کاربرد بسیار مناسب برای وبسایت‌ها و سامانه‌های که نیاز به مدیریت جلسات کاربران دارند.

**تجزیه و تحلیل داده:** 
Redis از داده‌های ساختاری چون مجموعه‌ها و لیست‌ها پشتیبانی می‌کند که می‌تواند برای تجزیه و تحلیل داده‌ها و انجام عملیات متقابل مرتبط با داده‌ها (Data Manipulation) استفاده شود. این کاربرد برای زمینه‌هایی مانند آمار، رتبه‌بندی، و پردازش داده‌های زمان واقعی مفید است.


با استفاده از Redis در این کاربردها، می‌توانید از سرعت بالا و انعطاف پذیری آن بهره‌مند شوید و به سادگی به چالش‌های مختلف مدیریت داده بپردازید.

## مقایسه Redis با MongoDB

**-مدل داده:** 

Redis:

از داده‌های ساختاری ساده مانند رشته‌ها، لیست‌ها، مجموعه‌ها و هش‌ها پشتیبانی می‌کند.

معمولاً برای داده‌های کوچک تا متوسط و ساختارهای ساده مناسب است.

MongoDB:

از مدل داده NoSQL پیشرفته‌تری برخوردار است و اطلاعات را به صورت اسناد BSON (Binary JSON) ذخیره می‌کند.

قابلیت پشتیبانی از ساختارهای پیچیده و اطلاعات حجیم را فراهم می‌کند.

**-عملکرد و سرعت:**

Redis:

به عنوان یک دیتابیس in-memory، Redis برای عملیات‌های خواندن و نوشتن بسیار سریع است.

مناسب برای استفاده در حالاتی که نیاز به پاسخگویی فوری و سرعت بالا است.

MongoDB:

عملکرد MongoDB برخی از سناریوهای خاص را از طریق شاخص‌ها (indexes) بهبود می‌بخشد اما ممکن است برای بعضی از عملیات‌ها کمی کند باشد.

مناسب برای داده‌های بزرگ و مدیریت داده‌هایی با تعداد زیاد اطلاعات.

**-مقیاس‌پذیری:**

Redis:

 به صورت افقی (horizontal scaling) مقیاس‌پذیری می‌کند، اما بیشتر بر روی یک نود متمرکز است.

معمولاً برای مواقعی که نیاز به توسعه عمودی (vertical scaling) و یک نود قدرتمند دارید مناسب است.

MongoDB:

 به صورت هر دو افقی و عمودی مقیاس‌پذیر است.

می‌توان به راحتی نود‌ها را افزایش داد یا به شبکه افزود.

**-تراکنش‌ها و انعطاف‌پذیری:** 

Redis:

 به عنوان یک دیتابیس نهان نمایه‌ای تراکنشات بسیار ساده را پشتیبانی می‌کند و انعطاف‌پذیری زیادی برای کاربردهای مشخص دارد.

مناسب برای مواردی که نیاز به انجام عملیات سریع و متناوب است.

MongoDB:

 تراکنشات پیشرفته‌تری را ارائه می‌دهد که برای تطابق با سطوح بالاتر انعطاف‌پذیری نیاز است.

برای کاربردهایی که نیاز به مدیریت داده‌های پیچیده‌تر و تراکنشات گسترده دارند مناسب است.

**-استفاده در موارد خاص:**

Redis:

مناسب برای حافظه نهان داده، سیستم صف، ذخیره و بازیابی سریع داده‌ها و کاربردهایی که نیاز به سرعت بالا و زمان واقعی دارند.

MongoDB:

مناسب برای مواردی که نیاز به ذخیره سازی داده‌های پیچیده، پرس و جو پیچیده، و مقیاس‌پذیری برای داده‌های بزرگ دارند.


به طور کلی، انتخاب بین Redis و MongoDB به موارد کاربردی خاص و نیازهای پروژه شما بستگی دارد. Redis برای کاربردهایی که نیاز به سرعت و پاسخگویی فوری دارند، در حالی که MongoDB برای مواردی که نیاز به مدیریت داده‌های پیچیده و مقیاس‌پذیری بالا دارند، مناسب است.

## مثال
**مثال استفاده از ردیس در Python:**

    ```
    import redis

    # اتصال به سرور ردیس
    r = redis.StrictRedis(host='localhost', port=6379, decode_responses=True)

    # ذخیره یک کلید و مقدار
    r.set('example_key', 'Hello, Redis!')

    # بازیابی مقدار
    value = r.get('example_key')
    print(value)  # خروجی: Hello, Redis!

    ```

**مثال استفاده از ردیس در Node.js:**

    ```
    const redis = require('redis');
    const client = redis.createClient();

    // ذخیره یک کلید و مقدار
    client.set('example_key', 'Hello, Redis!');

    // بازیابی مقدار
    client.get('example_key', (err, reply) => {
        console.log(reply); 
        // خروجی: Hello, Redis!
    });

    ```

